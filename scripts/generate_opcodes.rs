#!/usr/bin/env rust-script
//! Generates type-safe opcode enums from opcodes_spec.toml
//!
//! Usage: cargo run --bin generate_opcodes
//!
//! Reads opcodes_spec.toml and generates src/grue_compiler/opcodes.rs
//! with complete enum definitions and trait implementations.

use serde::Deserialize;
use std::collections::HashMap;
use std::fs;

#[derive(Debug, Deserialize)]
struct OpcodeSpec {
    op0: Vec<OpcodeEntry>,
    op1: Vec<OpcodeEntry>,
    op2: Vec<OpcodeEntry>,
    var: Vec<OpcodeEntry>,
}

#[derive(Debug, Deserialize)]
struct OpcodeEntry {
    name: String,
    value: u8,
    number: u16,
    stores: bool,
    branches: bool,
    min_version: u8,
    #[serde(default)]
    max_version: Option<u8>,
    description: String,
}

fn main() {
    println!("Reading opcodes_spec.toml...");
    let spec_content = fs::read_to_string("opcodes_spec.toml")
        .expect("Failed to read opcodes_spec.toml");

    let spec: OpcodeSpec = toml::from_str(&spec_content)
        .expect("Failed to parse opcodes_spec.toml");

    println!("Generating opcodes.rs...");
    let generated_code = generate_opcodes_module(&spec);

    fs::write("src/grue_compiler/opcodes.rs", generated_code)
        .expect("Failed to write src/grue_compiler/opcodes.rs");

    println!("âœ… Generated src/grue_compiler/opcodes.rs");
    println!("   - {} 0OP opcodes", spec.op0.len());
    println!("   - {} 1OP opcodes", spec.op1.len());
    println!("   - {} 2OP opcodes", spec.op2.len());
    println!("   - {} VAR opcodes", spec.var.len());
}

fn generate_opcodes_module(spec: &OpcodeSpec) -> String {
    let mut output = String::new();

    // File header
    output.push_str("// AUTO-GENERATED by scripts/generate_opcodes.rs\n");
    output.push_str("// DO NOT EDIT MANUALLY - Edit opcodes_spec.toml instead\n");
    output.push_str("//\n");
    output.push_str("// Type-safe Z-Machine opcode enums based on Z-Machine Standards v1.1\n\n");
    output.push_str("#![allow(dead_code)]\n\n");
    output.push_str("use super::codegen::InstructionForm;\n\n");

    // Generate Op0 enum
    output.push_str(&generate_enum("Op0", &spec.op0, "0OP form instructions"));
    output.push_str(&generate_metadata_impl("Op0", &spec.op0, "InstructionForm::Short"));

    // Generate Op1 enum
    output.push_str(&generate_enum("Op1", &spec.op1, "1OP form instructions"));
    output.push_str(&generate_metadata_impl("Op1", &spec.op1, "InstructionForm::Short"));

    // Generate Op2 enum
    output.push_str(&generate_enum("Op2", &spec.op2, "2OP form instructions (can use LONG or VAR form)"));
    output.push_str(&generate_metadata_impl("Op2", &spec.op2, "InstructionForm::Long"));

    // Generate OpVar enum
    output.push_str(&generate_enum("OpVar", &spec.var, "VAR form instructions"));
    output.push_str(&generate_metadata_impl("OpVar", &spec.var, "InstructionForm::Variable"));

    // Generate combined Opcode enum
    output.push_str(&generate_combined_enum());

    // Generate OpcodeMetadata trait
    output.push_str(&generate_metadata_trait());

    // Generate convenience constants
    output.push_str(&generate_convenience_constants(spec));

    output
}

fn generate_enum(name: &str, opcodes: &[OpcodeEntry], doc: &str) -> String {
    let mut output = String::new();

    output.push_str(&format!("/// {}\n", doc));
    output.push_str("#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n");
    output.push_str("#[repr(u8)]\n");
    output.push_str(&format!("pub enum {} {{\n", name));

    // Group opcodes by value to detect conflicts
    let mut value_groups: HashMap<u8, Vec<&OpcodeEntry>> = HashMap::new();
    for opcode in opcodes {
        value_groups.entry(opcode.value)
            .or_insert_with(Vec::new)
            .push(opcode);
    }

    for opcode in opcodes {
        let conflicts = &value_groups[&opcode.value];

        output.push_str(&format!("    /// {} ({})\n", opcode.description, opcode.number));
        if let Some(max_ver) = opcode.max_version {
            output.push_str(&format!("    /// V{}-V{}\n", opcode.min_version, max_ver));
        } else {
            output.push_str(&format!("    /// V{}+\n", opcode.min_version));
        }

        // If there are conflicts, use conditional compilation
        if conflicts.len() > 1 {
            // For V1-4 opcodes, prefer the earlier version
            // For V5+ opcodes with same value, use version-specific cfg
            if opcode.max_version.is_some() {
                // This is the older version (e.g., Not in V1-4, Sread in V1-3)
                // Skip it - we'll use the newer version
                continue;
            }
        }

        output.push_str(&format!("    {} = 0x{:02X},\n", opcode.name, opcode.value));
    }

    output.push_str("}\n\n");
    output
}

fn generate_metadata_impl(enum_name: &str, opcodes: &[OpcodeEntry], form: &str) -> String {
    let mut output = String::new();

    output.push_str(&format!("impl {} {{\n", enum_name));

    // raw_value method
    output.push_str("    /// Get the raw opcode number (0x00-0x1F)\n");
    output.push_str("    pub const fn raw_value(&self) -> u8 {\n");
    output.push_str("        *self as u8\n");
    output.push_str("    }\n\n");

    // stores_result method
    output.push_str("    /// Does this opcode store a result?\n");
    output.push_str("    pub const fn stores_result(&self) -> bool {\n");
    output.push_str("        match self {\n");
    for opcode in opcodes {
        if opcode.stores {
            output.push_str(&format!("            {}::{} => true,\n", enum_name, opcode.name));
        }
    }
    output.push_str("            _ => false,\n");
    output.push_str("        }\n");
    output.push_str("    }\n\n");

    // branches method
    output.push_str("    /// Does this opcode branch?\n");
    output.push_str("    pub const fn branches(&self) -> bool {\n");
    output.push_str("        match self {\n");
    for opcode in opcodes {
        if opcode.branches {
            output.push_str(&format!("            {}::{} => true,\n", enum_name, opcode.name));
        }
    }
    output.push_str("            _ => false,\n");
    output.push_str("        }\n");
    output.push_str("    }\n\n");

    // min_version method
    output.push_str("    /// Minimum Z-Machine version required\n");
    output.push_str("    pub const fn min_version(&self) -> u8 {\n");
    output.push_str("        match self {\n");

    // Group by version
    let mut by_version: HashMap<u8, Vec<&str>> = HashMap::new();
    for opcode in opcodes {
        by_version.entry(opcode.min_version)
            .or_insert_with(Vec::new)
            .push(&opcode.name);
    }

    for version in 1..=8 {
        if let Some(names) = by_version.get(&version) {
            let pattern = names.iter()
                .map(|n| format!("{}::{}", enum_name, n))
                .collect::<Vec<_>>()
                .join(" | ");
            output.push_str(&format!("            {} => {},\n", pattern, version));
        }
    }

    output.push_str("        }\n");
    output.push_str("    }\n\n");

    // form method
    output.push_str("    /// Get instruction form for this opcode\n");
    output.push_str("    pub const fn form(&self) -> InstructionForm {\n");
    output.push_str(&format!("        {}\n", form));
    output.push_str("    }\n");

    output.push_str("}\n\n");
    output
}

fn generate_combined_enum() -> String {
    let mut output = String::new();

    output.push_str("/// Combined opcode enum that can represent any Z-Machine instruction\n");
    output.push_str("#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n");
    output.push_str("pub enum Opcode {\n");
    output.push_str("    /// 0OP form opcode\n");
    output.push_str("    Op0(Op0),\n");
    output.push_str("    /// 1OP form opcode\n");
    output.push_str("    Op1(Op1),\n");
    output.push_str("    /// 2OP form opcode\n");
    output.push_str("    Op2(Op2),\n");
    output.push_str("    /// VAR form opcode\n");
    output.push_str("    OpVar(OpVar),\n");
    output.push_str("}\n\n");

    output.push_str("impl Opcode {\n");
    output.push_str("    /// Get the raw opcode value\n");
    output.push_str("    pub fn raw_value(&self) -> u8 {\n");
    output.push_str("        match self {\n");
    output.push_str("            Opcode::Op0(op) => op.raw_value(),\n");
    output.push_str("            Opcode::Op1(op) => op.raw_value(),\n");
    output.push_str("            Opcode::Op2(op) => op.raw_value(),\n");
    output.push_str("            Opcode::OpVar(op) => op.raw_value(),\n");
    output.push_str("        }\n");
    output.push_str("    }\n\n");

    output.push_str("    /// Does this instruction store a result?\n");
    output.push_str("    pub fn stores_result(&self) -> bool {\n");
    output.push_str("        match self {\n");
    output.push_str("            Opcode::Op0(op) => op.stores_result(),\n");
    output.push_str("            Opcode::Op1(op) => op.stores_result(),\n");
    output.push_str("            Opcode::Op2(op) => op.stores_result(),\n");
    output.push_str("            Opcode::OpVar(op) => op.stores_result(),\n");
    output.push_str("        }\n");
    output.push_str("    }\n\n");

    output.push_str("    /// Does this instruction branch?\n");
    output.push_str("    pub fn branches(&self) -> bool {\n");
    output.push_str("        match self {\n");
    output.push_str("            Opcode::Op0(op) => op.branches(),\n");
    output.push_str("            Opcode::Op1(op) => op.branches(),\n");
    output.push_str("            Opcode::Op2(op) => op.branches(),\n");
    output.push_str("            Opcode::OpVar(op) => op.branches(),\n");
    output.push_str("        }\n");
    output.push_str("    }\n\n");

    output.push_str("    /// Get minimum Z-Machine version\n");
    output.push_str("    pub fn min_version(&self) -> u8 {\n");
    output.push_str("        match self {\n");
    output.push_str("            Opcode::Op0(op) => op.min_version(),\n");
    output.push_str("            Opcode::Op1(op) => op.min_version(),\n");
    output.push_str("            Opcode::Op2(op) => op.min_version(),\n");
    output.push_str("            Opcode::OpVar(op) => op.min_version(),\n");
    output.push_str("        }\n");
    output.push_str("    }\n\n");

    output.push_str("    /// Get instruction form\n");
    output.push_str("    pub fn form(&self) -> InstructionForm {\n");
    output.push_str("        match self {\n");
    output.push_str("            Opcode::Op0(op) => op.form(),\n");
    output.push_str("            Opcode::Op1(op) => op.form(),\n");
    output.push_str("            Opcode::Op2(op) => op.form(),\n");
    output.push_str("            Opcode::OpVar(op) => op.form(),\n");
    output.push_str("        }\n");
    output.push_str("    }\n");
    output.push_str("}\n\n");

    output
}

fn generate_metadata_trait() -> String {
    let mut output = String::new();

    output.push_str("/// Trait for opcode metadata\n");
    output.push_str("pub trait OpcodeMetadata {\n");
    output.push_str("    fn raw_value(&self) -> u8;\n");
    output.push_str("    fn stores_result(&self) -> bool;\n");
    output.push_str("    fn branches(&self) -> bool;\n");
    output.push_str("    fn min_version(&self) -> u8;\n");
    output.push_str("    fn form(&self) -> InstructionForm;\n");
    output.push_str("}\n\n");

    for enum_name in &["Op0", "Op1", "Op2", "OpVar"] {
        output.push_str(&format!("impl OpcodeMetadata for {} {{\n", enum_name));
        output.push_str("    fn raw_value(&self) -> u8 { self.raw_value() }\n");
        output.push_str("    fn stores_result(&self) -> bool { self.stores_result() }\n");
        output.push_str("    fn branches(&self) -> bool { self.branches() }\n");
        output.push_str("    fn min_version(&self) -> u8 { self.min_version() }\n");
        output.push_str("    fn form(&self) -> InstructionForm { self.form() }\n");
        output.push_str("}\n\n");
    }

    output
}

fn generate_convenience_constants(spec: &OpcodeSpec) -> String {
    let mut output = String::new();

    output.push_str("// Convenience constants for common opcodes\n");
    output.push_str("// These can be used directly without enum qualification\n\n");

    // Most common 0OP opcodes
    for name in &["Quit", "NewLine", "Rtrue", "Rfalse"] {
        if spec.op0.iter().any(|op| &op.name == name) {
            output.push_str(&format!("pub const {}: Opcode = Opcode::Op0(Op0::{});\n",
                name.to_uppercase(), name));
        }
    }
    output.push_str("\n");

    // Most common 1OP opcodes
    for name in &["PrintPaddr", "Jz", "Load", "Ret", "Jump"] {
        if spec.op1.iter().any(|op| &op.name == name) {
            output.push_str(&format!("pub const {}: Opcode = Opcode::Op1(Op1::{});\n",
                name.to_uppercase(), name));
        }
    }
    output.push_str("\n");

    // Most common 2OP opcodes
    for name in &["Je", "Jl", "Jg", "Add", "Sub", "Mul", "Div", "Store"] {
        if spec.op2.iter().any(|op| &op.name == name) {
            output.push_str(&format!("pub const {}: Opcode = Opcode::Op2(Op2::{});\n",
                name.to_uppercase(), name));
        }
    }
    output.push_str("\n");

    // Most common VAR opcodes
    for name in &["CallVs", "PutProp", "Sread", "PrintChar", "PrintNum"] {
        if spec.var.iter().any(|op| &op.name == name) {
            output.push_str(&format!("pub const {}: Opcode = Opcode::OpVar(OpVar::{});\n",
                name.to_uppercase(), name));
        }
    }

    output
}
