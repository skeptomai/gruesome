# Main Loop Design Options for Grue Language

## Problem Statement

Currently, Grue games compile successfully but exit immediately after the `init` function runs because there's no main game loop to handle user input and command processing. We need to design how the main game loop should work in Grue.

## Design Requirements

1. **Interactive Command Processing**: Games need to prompt for input, read commands, parse them, and dispatch to appropriate functions
2. **Grammar Integration**: The main loop must integrate with our sophisticated ParserEngine and grammar system
3. **User-Friendly**: The syntax should be intuitive for game authors
4. **Extensible**: Advanced users should be able to customize behavior
5. **Z-Machine Compatible**: Must generate appropriate Z-Machine instructions (`read`, `print`, `call`, etc.)

## Option A: Simple Block Syntax

```grue
main {
    prompt("> ");
    let input = read_line();
    let result = parse(input);
    if (result.success) {
        dispatch(result.verb, result.args);
    } else {
        print("I don't understand that.");
    }
}
```

**Pros:**
- Direct control over loop logic
- Familiar imperative syntax
- Maximum flexibility

**Cons:**
- Requires users to understand parsing internals
- Lots of boilerplate code
- Easy to get wrong

**Complexity:** High - users responsible for all loop logic

## Option B: Event-Driven Syntax

```grue
main_loop {
    prompt: "> "
    
    on_input(command) {
        let parsed = parse(command);
        if (parsed.verb == "quit") {
            exit();
        }
        dispatch(parsed);
    }
    
    on_parse_error(input) {
        print("I don't understand '" + input + "'.");
    }
}
```

**Pros:**
- Clean separation of concerns
- Declarative approach
- Event handlers are intuitive

**Cons:**
- New syntax to learn
- Less flexible than direct control
- May need many event types

**Complexity:** Medium - framework handles loop, users handle events

## Option C: Functional Style

```grue
fn main_loop() {
    while (true) {
        print("> ");
        let input = read_input();
        
        match parse_command(input) {
            Success(cmd) => execute_command(cmd),
            ParseError(msg) => print("Error: " + msg),
            Quit => break
        }
    }
}
```

**Pros:**
- Familiar to programmers
- Full control over implementation
- Uses existing language constructs

**Cons:**
- Verbose and repetitive
- Requires deep understanding of parsing
- No automatic integration with grammar

**Complexity:** High - users responsible for complete implementation

## Option D: Configuration Style

```grue
game_loop {
    prompt: "> "
    parser: use_grammar
    error_message: "I don't understand that."
    
    before_input: {
        // Optional pre-input processing
        update_time();
    }
    
    after_command: {
        // Optional post-command processing  
        check_win_condition();
    }
}
```

**Pros:**
- Minimal syntax required
- Declarative configuration
- Easy to extend with new options

**Cons:**
- Less control over behavior
- May not cover all use cases
- Configuration can become complex

**Complexity:** Low - mostly configuration with optional hooks

## Option E: Automatic with Override (RECOMMENDED)

```grue
// Default: automatic main loop generated for all games
init {
    player.location = start_room;
    print("Welcome to Adventure!");
}
// Game immediately becomes interactive - no additional code needed

// Advanced games can customize behavior:
main_loop {
    prompt: "Adventure> "
    
    before_input: {
        if (lamp.lit && lamp.fuel <= 0) {
            print("Your lamp runs out of fuel!");
            lamp.lit = false;
        }
    }
    
    on_unknown_verb(verb) {
        print("I don't know how to '" + verb + "'.");
    }
    
    on_parse_error(input) {
        print("I don't understand '" + input + "'.");
    }
}
```

**Pros:**
- Zero learning curve for basic games
- Progressive disclosure - add complexity only when needed
- Powerful customization for advanced games
- Familiar patterns from other game engines
- Easy to implement incrementally

**Cons:**
- More complex to implement (automatic + override system)
- Magic behavior might surprise some users
- Need to document what the automatic behavior includes

**Complexity:** Low to High - scales with user needs

## Implementation Details for Option E

### Automatic Behavior (Generated by Compiler)
When no `main_loop` block is present, the compiler automatically generates:

1. **Prompt Display**: Shows "> " prompt
2. **Input Reading**: Uses Z-Machine `read` instruction
3. **Command Parsing**: Integrates with ParserEngine and compiled grammar
4. **Command Dispatch**: Calls appropriate verb functions based on grammar matches
5. **Error Handling**: Shows "I don't understand that." for unknown commands
6. **Loop Continuation**: Repeats until `quit` command

### Override Capabilities
The `main_loop` block allows customization of:

- **Custom Prompts**: Change the input prompt
- **Lifecycle Hooks**: `before_input`, `after_command`, `before_turn`, `after_turn`
- **Error Handling**: `on_unknown_verb`, `on_parse_error`, `on_disambiguation`
- **Special Commands**: `on_quit`, `on_save`, `on_restore`
- **State Management**: Custom turn counters, timers, events

### Z-Machine Code Generation
The main loop generates these Z-Machine instructions:

```
main_loop_start:
    print_paddr prompt_text    ; Show prompt
    read buffer parse_buffer   ; Get user input  
    call parser_routine        ; Parse command
    call dispatch_routine      ; Execute verb function
    jump main_loop_start       ; Loop back
```

## Decision Log

**Selected Option:** E (Automatic with Override)

**Rationale:**
- Provides immediate gratification - every Grue game becomes interactive without additional code
- Matches user expectations from other interactive fiction tools
- Scales from beginner to advanced use cases
- Can be implemented incrementally (start with automatic, add overrides later)
- Maintains the principle that Grue should be easy to get started with

**Next Steps:**
1. Implement automatic main loop generation in codegen phase
2. Add basic prompt/read/parse/dispatch cycle
3. Integrate with existing ParserEngine and grammar system
4. Test with existing example games
5. Add override syntax in future iteration

## Future Considerations

- **Performance**: Consider optimization for main loop (it runs frequently)
- **Debugging**: Add debugging hooks for main loop inspection
- **Save/Restore**: Integrate with Z-Machine save/restore instructions
- **Timers**: Support for timed events and turn counters
- **Multi-player**: Consider how main loop might work with multiple players
- **Scripting**: Support for automated command sequences for testing

## References

- Z-Machine Standards Document (read instruction specification)
- Inform 6/7 implementation patterns (research needed)
- PunyInform minimal.inf template (examine for patterns)
- Modern game engine main loop patterns (Unity, Godot, etc.)