# Pattern Matching Skip Label Bug Analysis

**Date**: December 14, 2025
**Status**: CRITICAL BUG - Pattern matching broken after grammar refactoring
**Symptom**: "look around" and "look at mailbox" both fail to match correct patterns

---

## Executive Summary

After the December 11-12 grammar refactoring that extracted pattern handlers to separate methods, pattern matching is broken. The root cause is **skip label misdirection** - when pattern checks fail, they jump to the wrong code location (handler code instead of next pattern check).

**Two Issues Identified**:
1. **Parse buffer offset bug** (FIXED): Word 2 load used offset 1 instead of 3
2. **Skip label misdirection** (UNFIXED): Skip labels point to wrong addresses

---

## The Bug

**Test Case**: `printf "look around\nquit\ny\n" | cargo run --bin gruesome tests/mini_zork_test_new.z3`

**Expected**: "You are standing in an open field..." (calls `look_around()`)
**Actual**: "You can't see any such thing." (calls `examine("around")`)

**Test Case**: `printf "look at mailbox\nquit\ny\n" | cargo run --bin gruesome tests/mini_zork_test_new.z3`

**Expected**: "The small mailbox is closed." (calls `examine(mailbox)`)
**Actual**: "You are standing in an open field..." (calls `look_around()` default)

---

## Grammar Definition

From `examples/mini_zork.grue`:
```grue
verb "look" {
    default => look_around(),
    "at" + noun => examine($2),
    "around" => look_around()
}
```

**Pattern Execution Order** (as generated by compiler):
1. Literal patterns ("around") → `generate_literal_patterns()`
2. Literal+noun patterns ("at" + noun) → `generate_literal_noun_patterns()`
3. Verb+noun patterns → `generate_verb_noun_patterns()`
4. Default patterns → `generate_default_pattern()`

---

## Expected Control Flow

### For "look around" (word_count = 2):

1. **Literal Pattern "around" Check**:
   - Check word_count == 2 → TRUE ✅
   - Load word 1 dictionary address (offset 3) → "around"
   - Compare with "around" → MATCH ✅
   - Execute `look_around()` → **SUCCESS** ✅
   - Jump to main loop

2. **Should NEVER reach**: Literal+noun or default patterns

### For "look at mailbox" (word_count = 3):

1. **Literal Pattern "around" Check**:
   - Check word_count == 2 → FALSE (count is 3) ❌
   - Branch to `skip_literal_label` → Jump to literal+noun pattern

2. **Literal+Noun Pattern "at" + noun Check**:
   - Check word_count >= 3 → TRUE ✅
   - Load word 1 (offset 3) → "at"
   - Compare with "at" → MATCH ✅
   - Load word 2 (offset 5) → "mailbox"
   - Convert to object ID → mailbox object
   - Execute `examine(mailbox)` → **SUCCESS** ✅
   - Jump to main loop

3. **Should NEVER reach**: Default pattern

---

## Actual Control Flow (Broken)

### Current Behavior for "look around":

**Debug Findings**:
- ❌ NO Variable 7 writes detected (pattern matching code NOT executing)
- ❌ Result: "You can't see any such thing" (examine() error message)
- ❌ Conclusion: "at" + noun pattern is matching when it shouldn't

**What's Happening**:
1. Literal pattern "around" check somehow FAILS or SKIPS
2. Falls through to "at" + noun pattern
3. "at" + noun pattern word_count check (>= 3) should REJECT (word_count = 2)
4. But somehow executes `examine("around")` anyway
5. examine() can't find object "around" → "You can't see any such thing"

---

## Root Cause Analysis

### Issue #1: Parse Buffer Offset (FIXED ✅)

**File**: `src/grue_compiler/codegen_grammar.rs:860`

**Before**:
```rust
Operand::SmallConstant(1), // WRONG: Offset 1 = word 0 dict addr (verb)
```

**After**:
```rust
Operand::SmallConstant(3), // FIXED: Offset 3 = word 1 dict addr (literal word)
```

**Parse Buffer Layout**:
```
Byte 0: max words
Byte 1: word count (2 for "look around")
Bytes 2-3: word 0 dict addr (low, high) = "look" ← offset 1 in word addressing
Bytes 4-5: word 0 text pos, length
Bytes 6-7: word 1 dict addr (low, high) = "around" ← offset 3 in word addressing
```

**Status**: ✅ Fixed - now loads correct word from parse buffer

---

### Issue #2: Skip Label Misdirection (UNFIXED ❌)

**Problem**: Skip labels created during pattern generation don't resolve to correct addresses.

**Evidence**:
1. Pattern matching code generates skip labels with monotonic IDs (✅ correct)
2. Skip labels should point to NEXT pattern's check code
3. But after refactoring, label addresses are being recorded at wrong locations

**Code Structure Analysis**:

**Literal Pattern** (`codegen_grammar.rs:774-1018`):
```rust
fn generate_literal_patterns() {
    for each literal pattern:
        skip_literal_label = self.next_string_id++  // Create skip label

        // Pattern checks
        if word_count != 2: branch to skip_literal_label
        if word != literal: branch to skip_literal_label

        // Handler execution (if pattern matched)
        execute_handler()
        jump_to_main_loop()

        // Define skip label HERE (line 1012)
        self.reference_context.ir_id_to_address.insert(skip_literal_label, self.code_address)
}
```

**Literal+Noun Pattern** (`codegen_grammar.rs:1025-1267`):
```rust
fn generate_literal_noun_patterns() {
    for each literal+noun pattern:
        skip_insufficient_words = self.next_string_id++
        skip_literal_noun_label = self.next_string_id++

        // Pattern checks
        if word_count < 3: branch to skip_insufficient_words
        if word1 != literal: branch to skip_literal_noun_label

        // Handler execution (if pattern matched)
        execute_handler()
        jump_to_main_loop()

        // Define BOTH skip labels HERE (lines 1253, 1261)
        self.record_final_address(skip_literal_noun_label, self.code_address)
        self.record_final_address(skip_insufficient_words, self.code_address)
}
```

**CRITICAL INSIGHT**: Skip labels are defined AFTER the handler code, which means they point to the address AFTER the jump-to-main-loop instruction. The NEXT code executed is the NEXT pattern's check code.

This is **CORRECT** design!

---

## Why It's Broken

**Hypothesis**: The skip labels ARE pointing to the next pattern's check code, but there's a mismatch between:
1. Where the label is DEFINED (after handler code)
2. Where the NEXT pattern's code actually STARTS

**Possible Causes**:
1. **Label definition uses `ir_id_to_address` vs `record_final_address`** inconsistently
2. **Address mapping** uses different offsets (relative vs absolute)
3. **Reference resolution** may be using wrong address space or offset calculation

**Key Code Differences**:

**Literal pattern** (line 1010-1012):
```rust
self.reference_context.ir_id_to_address.insert(skip_literal_label, self.code_address);
```

**Literal+noun pattern** (lines 1253, 1261):
```rust
self.record_final_address(skip_literal_noun_label, self.code_address);
self.record_final_address(skip_insufficient_words, self.code_address);
```

**INCONSISTENCY**: Literal pattern uses `ir_id_to_address.insert()` directly, while literal+noun uses `record_final_address()`.

---

## The Fix

### Strategy: Standardize Label Definition Method

**Problem**: Mixed use of `ir_id_to_address.insert()` and `record_final_address()` for skip labels.

**Solution**: Use `record_final_address()` consistently for ALL skip labels.

**Rationale**: `record_final_address()` is the standard method used throughout the codebase for label registration. It properly handles both `ir_id_to_address` mapping AND `label_addresses` tracking.

### Implementation

**File**: `src/grue_compiler/codegen_grammar.rs`

**Change 1**: Line 1010-1012 (Literal pattern skip label)

**Before**:
```rust
// Register label in ir_id_to_address for branch resolution (this is what the resolver looks for)
self.reference_context
    .ir_id_to_address
    .insert(skip_literal_label, self.code_address);
```

**After**:
```rust
// Register skip label using standard method (consistent with literal+noun pattern)
self.record_final_address(skip_literal_label, self.code_address);
```

**Change 2**: Verify all other pattern handlers use `record_final_address()` consistently

---

## Testing Protocol

After applying fix:

```bash
# Compile mini_zork
cargo run --bin grue-compiler -- examples/mini_zork.grue -o tests/mini_zork_test_new.z3

# Test Case 1: Literal pattern
printf "look around\nquit\ny\n" | cargo run --bin gruesome tests/mini_zork_test_new.z3
# Expected: Room description (look_around() executed)

# Test Case 2: Literal+noun pattern
printf "look at mailbox\nquit\ny\n" | cargo run --bin gruesome tests/mini_zork_test_new.z3
# Expected: "The small mailbox is closed." (examine(mailbox) executed)

# Test Case 3: Default pattern
printf "look\nquit\ny\n" | cargo run --bin gruesome tests/mini_zork_test_new.z3
# Expected: Room description (look_around() default executed)

# Test Case 4: Regression - examine
printf "examine mailbox\nquit\ny\n" | cargo run --bin gruesome tests/mini_zork_test_new.z3
# Expected: "The small mailbox is closed." (examine verb, not look verb)
```

---

## Additional Investigation Needed

If fixing the label definition method doesn't resolve the issue, investigate:

1. **Label Resolution**: Check `codegen_resolve.rs` to see how Branch references are resolved
2. **Address Calculation**: Verify offset calculations in reference resolution
3. **Pattern Order**: Confirm patterns are generated in the expected order
4. **Code Address Tracking**: Verify `self.code_address` is correct at label definition time

---

## Related Issues

- **ONGOING_TASKS.md**: Hash-based label ID bug (already converted to monotonic IDs)
- **Grammar Refactoring**: December 11-12, 2025 - extracted pattern handlers to separate methods
- **Previous Investigation**: `docs/literal_pattern_regression_analysis.md`

---

## Success Criteria

✅ "look around" executes `look_around()` function
✅ "look at mailbox" executes `examine(mailbox)` function
✅ "look" executes `look_around()` default function
✅ "examine mailbox" executes `examine(mailbox)` function
✅ All patterns match correctly based on word count and literal/noun checks
✅ No pattern matching code should execute twice for same input
✅ Skip labels should jump to next pattern check code, not handler code

---

## Implementation Plan

**Phase 1**: Fix Label Definition Method (IMMEDIATE)
1. Change line 1010-1012 to use `record_final_address()`
2. Verify all pattern handlers use consistent method
3. Test with mini_zork

**Phase 2**: Debug Logging (if Phase 1 fails)
1. Add logging to `record_final_address()` to track label registration
2. Add logging to branch resolution to see where branches actually jump
3. Compare expected vs actual jump targets

**Phase 3**: Address Resolution Investigation (if Phase 2 reveals issues)
1. Review `codegen_resolve.rs` Branch reference resolution
2. Check for address space mismatches (Code vs Objects)
3. Verify offset calculations use correct base addresses
