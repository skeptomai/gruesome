# Control Flow Bug - Plan of Attack

## Background

We've isolated a critical Z-Machine bytecode generation bug to complex control flow features. Simple programs (like single print statements) work perfectly, but mini_zork.grue generates invalid `0x00` opcodes at runtime.

**Key Discovery**: The issue is NOT in basic instruction generation (strings, simple calls work), but in complex control flow (conditionals, branches, jumps) that mini_zork uses heavily.

## üéØ **Systematic Analysis Plan**

### **Phase 1: Create Minimal Reproduction Case**
Instead of jumping into complex mini_zork, build up complexity incrementally:

1. **Start with working case**: `debug_assignment.z3` (2 prints - works ‚úÖ)
2. **Add ONE feature at a time**:
   ```grue
   // Test 1: Simple conditional
   init {
       if true {
           print("true branch");
       }
   }
   ```
3. **Test each addition** until we find the **exact feature** that breaks
4. **Document the breaking change** before proceeding

### **Phase 2: Examine Generated Bytecode Patterns**
For the breaking case:
```bash
xxd -s 0x[entry_point] -l 32 broken_test.z3
```
- Compare byte-by-byte with working case
- Identify **exactly which instruction generates `0x00`**
- Trace back to the specific code generation function

### **Phase 3: Debug Specific Instruction Generation**
Once we identify the problematic instruction type:
```bash
RUST_LOG=debug cargo run --bin grue-compiler -- broken_test.grue 2>&1 | grep -A5 -B5 "generate_"
```
- Focus on **one specific function** (e.g., `generate_conditional_branch`)
- Add targeted debug prints to see **exact bytes being emitted**
- Verify against Z-Machine specification

### **Phase 4: Fix with Validation**
1. **Fix the specific instruction generation bug**
2. **Test the minimal reproduction case** 
3. **Test increasingly complex cases**
4. **Only then test mini_zork.grue**
5. **Commit fix immediately** to avoid regression

## üö® **Critical Safeguards**

1. **Never test mini_zork directly** - always use minimal cases
2. **One change at a time** - no compound fixes
3. **Validate each step** before proceeding  
4. **Keep working test cases** as regression tests
5. **Document exact failure point** before changing code

## üîç **Specific Focus Areas**

Based on mini_zork debug output showing lots of `generate_conditional_branch`, I suspect:
- Branch offset calculations
- Label resolution in complex control flow
- Instruction length miscalculations causing PC misalignment

## Current Status

- ‚úÖ **Basic bytecode generation works** (print statements)
- ‚úÖ **String handling works** (print_paddr opcodes) 
- ‚úÖ **Header generation works** (proper entry points)
- ‚úÖ **Fixed Long form instruction encoding bug** (operand bit positioning)
- ‚ùå **Complex control flow generates invalid `0x00` opcodes**

## Error Details

- **File**: mini_zork.z3
- **Initial PC**: 0x085e  
- **Failure Address**: 0x0860
- **Error**: "Invalid Long form opcode 0x00 at address 0860"
- **Hex Pattern**: `a9 01 00 d2 9b 01 01 00 9d 01 a9 01 00 d2 9b 01`

## Next Actions

Proceed with Phase 1: Create minimal conditional test case to isolate the exact breaking feature.

## Regression Prevention

- Always test with minimal cases first
- Document each working configuration
- Commit fixes immediately
- Maintain regression test suite