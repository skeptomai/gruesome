// Mini Zork - Sample Grue Game for Compiler Testing
// This game implements the classic opening of Zork I
// to validate our Z-Machine compiler implementation
//
// Room Layout (Consistent Directional Movement):
//
//     [forest_path] -----> [forest] -----> [clearing]
//           |                |               |
//           v                v               v
//   [north_of_house]   [behind_house] -------|
//           |                |
//           v                v
//   [west_of_house] <---[south_of_house]
//
// Movement flows naturally: house perimeter → forest path → deep forest → clearing

world {
    room west_of_house "West of House" {
        desc: "You are standing in an open field west of a white house, with a boarded front door."

        object mailbox {
            names: ["a small mailbox", "mailbox", "box"]
            desc: "a small mailbox"
            openable: true
            container: true
            open: false
            
            contains {
                object leaflet {
                    names: ["leaflet", "paper"]
                    desc: "\"WELCOME TO DORK!\n\nDORK is a game of adventure, danger, and low cunning. In it you will explore some of the most amazing territory ever seen by mortals. No computer should be without one!\""
                    takeable: true
                }
            }
        }
        
        exits: {
            north: north_of_house,
            south: south_of_house,
            east: blocked("The door is boarded and you can't remove the boards.")
        }
        
        on_enter: {
            if !west_of_house.visited {
                println("Welcome to Dork!");
            }
        }
    }
    
    room north_of_house "North of House" {
        desc: "You are facing the north side of a white house. There is no door here, and all the windows are boarded up. To the north a narrow path winds through the trees."
        exits: { 
            south: west_of_house,
            north: forest_path
        }
    }
    
    room south_of_house "South of House" {
        desc: "You are facing the south side of a white house. A path leads to the east."
        exits: { 
            north: west_of_house,
            east: behind_house
        }
    }
    
    room behind_house "Behind House" {
        desc: "You are behind the white house. A path leads into the forest to the east. In one corner of the house there is a small window which is slightly ajar."
        
        object window {
            names: ["window", "small window"]
            desc: "The window is " + (window.open ? "open" : "slightly ajar") + "."
            openable: true
        }
        
        exits: {
            west: south_of_house,
            east: forest,
            south: clearing
        }
        
        on_look: {
            if window.open {
                println("Through the open window you can see into what appears to be a kitchen.");
            }
        }
    }
    
    room forest_path "Forest Path" {
        desc: "This is a path winding through a dimly lit forest. The path heads north-south here. One particularly large tree with some low branches stands at the edge of the path."

        // Directional consistency: south leads back toward house, east leads deeper into forest

        object tree {
            names: ["tree", "large tree"]
            desc: "The tree has low branches that look climbable."
            takeable: false
        }

        exits: {
            south: north_of_house,
            east: forest,
            up: up_a_tree
        }
    }
    
    room up_a_tree "Up a Tree" {
        desc: "You are about 10 feet above the ground nestled among some large branches. The nearest branch above you is above your reach."
        
        object nest {
            names: ["bird's nest", "nest"]
            desc: "In the bird's nest is a large egg encrusted with precious jewels."
            container: true
            open: true
            
            contains {
                object egg {
                    names: ["jewel-encrusted egg", "egg", "large egg"]
                    desc: "The egg is covered with fine gold inlay, and ornamented in lapis lazuli and mother-of-pearl. Unlike most eggs, this one is hinged and closed with a delicate looking clasp."
                    openable: true
                    container: true
                    valuable: true
                    takeable: true
                }
            }
        }
        
        exits: {
            down: forest_path
        }
    }
    
    room forest "Forest" {
        desc: "This is a forest, with trees in all directions. To the east, there appears to be sunlight."

        // Linear progression: south leads to clearing (not east), creating consistent flow
        exits: {
            north: forest_path,
            south: clearing,
            west: behind_house
        }
    }
    
    room clearing "Forest Clearing" {
        desc: "You are in a clearing, with a forest surrounding you on all sides. A path leads south."

        // Removed circular south→forest exit for cleaner geography; players can return via behind_house
        exits: {
            north: behind_house,
        }
    }
}

grammar {
    verb "score" {
        default => handle_score()
    }

    verb "moves" {
        default => handle_moves()
    }

    verb "look" {
        default => look_around(),
        "at" + noun => examine($2),
        "around" => look_around()
    }
    
    verb "examine" {
        noun => examine($noun)
    }
    
    verb "open" {
        noun => handle_open($noun)
    }
    
    verb "close" {
        noun => handle_close($noun)  
    }
    
    verb "take" {
        noun => handle_take($noun),
        "all" => take_all()
    }
    
    verb "drop" {
        noun => handle_drop($noun)
    }
    
    verb "inventory" {
        default => show_inventory()
    }
    
    verb "go" {
        noun => handle_go($noun)
    }
    
    verb "north" {
        default => handle_go("north")
    }
    
    verb "south" {
        default => handle_go("south")
    }
    
    verb "east" {
        default => handle_go("east")
    }
    
    verb "west" {
        default => handle_go("west")
    }
    
    verb "up" {
        default => handle_go("up")
    }
    
    verb "down" {
        default => handle_go("down")
    }
    
    verb "climb" {
        noun => handle_climb($noun)
    }
    
    verb "read" {
        noun => handle_read($noun)
    }

    verb "quit" {
        default => handle_quit()
    }

    verb "exit" {
        default => handle_quit()
    }

    // Add yes/y/no/n to dictionary (used for quit confirmation)
    verb "yes" {
        default => handle_yes()
    }

    verb "y" {
        default => handle_yes()
    }

    verb "no" {
        default => handle_no()
    }

    verb "n" {
        default => handle_no()
    }
}

fn handle_score(){
    print("Your score is ");  // Print without newline (Z-Machine spec compliant)
    print_num(player.score);   // Print number without newline
    new_line();               // Explicit newline for proper formatting
}

fn handle_moves(){
    print("You have taken ");  // Print without newline (Z-Machine spec compliant)
    print_num(player.moves);   // Print number without newline
    print(" moves.");         // Print without newline
    new_line();               // Explicit newline for proper formatting
}

fn look_around() {
    clear_quit_state();
    println(player.location.desc);
    list_objects(player.location);

    // Call location-specific look handler if it exists
    if player.location.on_look {
        player.location.on_look();
    }
}

fn examine(obj) {
    clear_quit_state();

    if !player_can_see(obj) {
        println("You can't see any such thing.");
        return;
    }

    // Special handling for dynamic descriptions
    if obj == mailbox {
        print("The small mailbox is ");
        if mailbox.open {
            print("open");
        } else {
            print("closed");
        }
        println(".");
        return;
    }

    // Special handling for nest - show natural description including contents
    if obj == nest {
        if egg.location == nest {
            println("A bird's nest rests among the branches, and you can see a jewel-encrusted egg nestled inside.");
        } else {
            println("A bird's nest rests among the branches, but it appears to be empty.");
        }
        return;
    }

    println(obj.desc);
}

fn handle_open(obj) {
    if !player_can_see(obj) {
        println("You can't see any such thing.");
        return;
    }

    if !obj.openable {
        println("You can't open that.");
        return;
    }

    if obj.open {
        println("It's already open.");
    } else {
        obj.open = true;
        if obj.container && !obj.empty() {
            println("The " + obj.name + " contains:");
            list_contents(obj);
        }
    }
}

fn handle_close(obj) {
    if !player_can_see(obj) {
        println("You can't see any such thing.");
        return;
    }
    
    if !obj.openable {
        println("You can't close that.");
        return;
    }
    
    if !obj.open {
        println("It's already closed.");
    } else {
        obj.open = false;
        println("Closed.");
    }
}

fn handle_take(obj) {
    clear_quit_state();
    if obj.location == player {
        println("You already have that.");
        return;
    }

    if !player_can_see(obj) {
        println("You can't see any such thing.");
        return;
    }

    // Check if object is takeable
    if obj.takeable == false {
        println("You can't take that.");
        return;
    }

    // Check if object is inside a closed container
    if obj.location.container && !obj.location.open {
        println("The " + obj.location.name + " is closed.");
        return;
    }
    
    move(obj, player);
    println("Taken.");
}

fn handle_take(leaflet){
    clear_quit_state();

    if leaflet.location == player {
        println("You already have that.");
        return;
    }

    if !player_can_see(leaflet) {
        println("You can't see any such thing.");
        return;
    }

    move(leaflet, player);
    player.score = player.score + 2;

    println("Took leaflet.");
}

fn handle_take(egg){
    clear_quit_state();
    if egg.location == player {
        println("You already have that.");
        return;
    }

    if !player_can_see(egg) {
        println("You can't see any such thing.");
        return;
    }

    move(egg, player);
    player.score = player.score + 5;

    println("You are the proud owner of a very special egg.. Is it ticking?");
}

fn handle_drop(obj) {
    if obj.location != player {
        println("You don't have that.");
        return;
    }
    
    move(obj, player.location);
    println("Dropped.");
}

fn handle_drop(egg) {
    if egg.location != player {
        println("You don't have that.");
        return;
    }
    
    move(egg, player.location);
    println("Ok, now I really think it's ticking. Perhaps you should walk away... quickly");    
}

fn show_inventory() {
    let items = player.contents();
    if items.empty() {
        println("You are empty-handed.");
    } else {
        println("You are carrying:");
        for item in items {
            println("  " + item.name);
        }
    }
}

fn handle_go(direction) {
    clear_quit_state();
    let exit = player.location.get_exit(direction);

    if exit.none() {
        println("You can't go that way.");
        return;
    }

    if exit.blocked {
        println(exit.message);  // StringAddress system automatically detects type and uses print_paddr
        return;
    }

    // Call location on_exit handler if it exists
    if player.location.on_exit {
        player.location.on_exit();
    }

    // Move player to destination room
    move(player, exit.destination);
    player.location.visited = true;

    // *** Increment move counter on successful movement ***
    player.moves = player.moves + 1;

    // Call location on_enter handler if it exists
    if player.location.on_enter {
        player.location.on_enter();
    }

    // Display new room description
    look_around();
}

fn handle_climb(obj) {
    if (player.location == forest_path) {
        handle_climb(tree);
    }
    println("You can't climb that.");
}

fn handle_climb(tree){
    if (player.location == forest_path) {
        handle_go("up");
    }
}

fn handle_read(obj) {
    if !player_can_see(obj) {
        println("You can't see any such thing.");
        return;
    }

    if obj == leaflet {
        println(obj.desc);
    } else {
        println("There's nothing to read on that.");
    }
}

fn handle_quit() {
    print("Are you sure you want to quit? (y/n) ");
    player.quit_pending = true;
}

fn handle_yes() {
    if player.quit_pending {
        player.quit_pending = false;
        quit();
    } else {
        println("Yes to what?");
    }
}

fn handle_no() {
    if player.quit_pending {
        player.quit_pending = false;
        println("OK, continuing game.");
    } else {
        println("No to what?");
    }
}

fn clear_quit_state() {
    player.quit_pending = false;
}

fn player_can_see(obj) -> bool {
    // Handle null/invalid object (object 0)
    if obj == 0 {
        return false;
    }

    // Player can see objects in current location or in inventory
    if obj.location == player.location {
        return true;
    }

    if obj.location == player {
        return true;
    }

    // Can see objects in open containers in current location
    if obj.location.container {
        if obj.location.open {
            if obj.location.location == player.location {
                return true;
            }
        }
    }

    return false;
}

fn list_objects(location) {
    let objects = location.contents();

    for obj in objects {
        if obj != player {
            // Special description for nest
            if obj == nest {
                if egg.location == nest {
                    println("There is a bird's nest here with a jewel-encrusted egg visible inside.");
                } else {
                    println("There is an empty bird's nest here.");
                }
            } else {
                println("There is " + obj.name + " here.");
            }
        }
    }
}

fn list_contents(container) {
    let contents = container.contents();
    for item in contents {
        println("  " + item.name);
    }
}

fn take_all() {
    let objects = player.location.contents();
    let taken = 0;
    
    for obj in objects {
        if obj != player && obj.takeable != false {
            move(obj, player);
            println(obj.name + ": Taken.");
            taken = taken + 1;
        }
    }
    
    if taken == 0 {
        println("There's nothing here to take.");
    }
}

init {
    // Set up initial game state
    player.location = west_of_house;
    player.score = 0;      // Explicit initialization
    player.moves = 0;      // Start move counter
    west_of_house.visited = true;
    
    // Print game banner
    println("DORK I: The Last Great Empire");
    println("Copyright (c) 2025 Grue Games. All rights reserved.");
    println("ZORK is a registered trademark of Infocom, Inc.");
    println("DORK is .... not");
    println("Revision 1 / Serial number 8675309");
    println("");
    
    // Show initial location
    look_around();
}