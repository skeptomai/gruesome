# Memory Collision Analysis: DeferredBranchPatch vs UnresolvedReference

## PURPOSE
Identify specific memory locations and instruction patterns where DeferredBranchPatch and UnresolvedReference systems could patch overlapping bytes, causing memory corruption.

## CONFIRMED COLLISION CASE

### Evidence from Real Compilation
**Source**: Discovered during mini_zork.z3 compilation analysis

```
Address Range: 0x17a6 - 0x17a8

DeferredBranchPatch:
- Instruction: GetChild (1OP, requires branch parameter)
- Instruction Start: 0x17a6
- Branch Offset Location: 0x17a7-0x17a8 (2 bytes)
- Target: Fallthrough label for "no child" case

UnresolvedReference:
- Reference Type: GlobalsBase
- Operand Location: 0x17a7-0x17a8 (2 bytes)
- Target: Global variables base address from header
- Purpose: Next instruction needs global variable access
```

**Result**: Both systems attempt to patch bytes 0x17a7-0x17a8, causing:
- Invalid branch offset: 0x13 0x01 = 4865 (out of bounds)
- Corrupted global reference
- Runtime crash with "Invalid Long form opcode 0x00 at address 0x2aa7"

## COLLISION PATTERNS

### Pattern 1: Branch Instruction + Global Variable Access
**Trigger**: Any branch instruction immediately followed by instruction accessing globals

**Examples**:
```
GetChild object -> (result) ?(label)    // DeferredBranchPatch at offset+1,+2
LoadVar global_var -> result            // UnresolvedReference at offset+1,+2 (GlobalsBase)
```

**Memory Layout**:
```
Offset+0: Branch instruction opcode
Offset+1: Branch offset byte 1    ← DeferredBranchPatch writes here
Offset+2: Branch offset byte 2    ← DeferredBranchPatch writes here
Offset+1: Global base byte 1      ← UnresolvedReference writes here (COLLISION!)
Offset+2: Global base byte 2      ← UnresolvedReference writes here (COLLISION!)
```

### Pattern 2: Branch Instruction + Function Call
**Trigger**: Branch instruction followed by function call

**Examples**:
```
GetSibling object -> (result) ?(label)  // DeferredBranchPatch
CallBuiltin func_id                     // UnresolvedReference (FunctionCall type)
```

### Pattern 3: Branch Instruction + String Reference
**Trigger**: Branch instruction followed by instruction using string addresses

**Examples**:
```
TestAttr object, attr -> ?(label)       // DeferredBranchPatch
PrintPaddr string_address               // UnresolvedReference (StringRef type)
```

### Pattern 4: Branch Instruction + Dictionary Lookup
**Trigger**: Branch instruction followed by dictionary operations

**Examples**:
```
JE var, value -> ?(label)               // DeferredBranchPatch
LookupWord word_string                  // UnresolvedReference (DictionaryRef type)
```

## INSTRUCTION SEQUENCE ANALYSIS

### High-Risk Instruction Pairs

#### 1. Object Hierarchy + Global Access
```grue
if (get_child(room) != 0) {
    global_var = some_value;  // Global access after branch
}
```
**Z-Machine Sequence**:
- GetChild room -> temp ?(no_child_label)
- StoreVar temp -> global_200  ← GlobalsBase reference collision

#### 2. Property Testing + Function Calls
```grue
if (test_attr(object, VISITED)) {
    call_builtin(describe_room);  // Function call after branch
}
```
**Z-Machine Sequence**:
- TestAttr object, VISITED -> ?(not_visited_label)
- Call describe_room  ← FunctionCall reference collision

#### 3. Condition Checking + String Output
```grue
if (current_room == KITCHEN) {
    print("You are in the kitchen");  // String after branch
}
```
**Z-Machine Sequence**:
- JE current_room, KITCHEN -> ?(not_kitchen_label)
- PrintPaddr kitchen_string  ← StringRef reference collision

### Builtin Functions Creating Collisions

#### GetChild/GetSibling (High Risk)
**Source**: `codegen_builtins.rs:550-566, 591-607`
- ALWAYS emit branch parameters (required by Z-Machine spec)
- Commonly followed by variable assignments or function calls
- **Fixed**: Now emit proper fallthrough labels, but collision risk remains

#### TestAttr (Medium Risk)
**Usage**: Property and state checking in game logic
- Branch on attribute presence/absence
- Often followed by state changes or output

#### Comparison Operations (Medium Risk)
**Generated by**: if/while/for statements
- JE, JL, JG instructions with branch parameters
- Control flow operations often followed by assignments

## MEMORY SPACE COLLISION POINTS

### CodeSpace Collisions
**Most Common**: Branch instructions in generated function code

**Risk Factors**:
- Dense instruction sequences
- Complex control flow (if/while/for)
- Frequent function calls and builtin usage

### Pattern Detection in Code Generation

#### Grammar System (High Risk)
**Location**: `codegen.rs:6900-7500`
- Multiple branch instructions for verb/object matching
- Frequent dictionary lookups and function calls
- **Evidence**: Many comments about "automatic DeferredBranchPatch creation"

#### Object Property System (High Risk)
**Location**: `codegen.rs:5900-6100`
- Property access with attribute testing
- String property handling with packed addresses
- Complex conditional logic

#### Builtin System (Medium Risk)
**Location**: `codegen.rs:11300-13500`
- Complex multi-instruction builtins
- Mixed branch/reference patterns
- String and function address resolution

## ROOT CAUSE: ARCHITECTURAL ASSUMPTIONS

### DeferredBranchPatch Assumptions
1. **Exclusive access**: Assumes sole ownership of branch_offset_location bytes
2. **No coordination**: No awareness of other patching systems
3. **Late patching**: Applied during resolve_deferred_branches()

### UnresolvedReference Assumptions
1. **Exclusive access**: Assumes sole ownership of reference.location bytes
2. **No coordination**: No awareness of other patching systems
3. **Late patching**: Applied during main reference resolution loop

### Fundamental Design Flaw
**Both systems operate under the false assumption that they have exclusive access to their target memory locations**

## COLLISION DETECTION REQUIREMENTS

### Memory Range Overlap Detection
For any two patches to be safe, their memory ranges must not overlap:
```rust
fn patches_overlap(patch1: &Patch, patch2: &Patch) -> bool {
    let range1 = patch1.location..(patch1.location + patch1.size);
    let range2 = patch2.location..(patch2.location + patch2.size);
    range1.start < range2.end && range2.start < range1.end
}
```

### Critical Address Ranges to Monitor
1. **Branch offset locations**: `instruction_address + branch_offset_position`
2. **Operand locations**: `instruction_address + operand_position`
3. **Multi-byte patches**: Both 1-byte and 2-byte patch overlaps

## PREVENTION STRATEGIES

### 1. Unified Patch Queue
**Solution**: Single system managing all patches with conflict detection
```rust
enum PatchEntry {
    Branch { address: usize, target_label: IrId, condition: BranchCondition },
    Reference { address: usize, target: ReferenceTarget, size: usize },
}
```

### 2. Address Range Validation
**Solution**: Reject overlapping patches during creation
```rust
fn add_patch(&mut self, patch: PatchEntry) -> Result<(), CollisionError> {
    for existing in &self.patches {
        if patches_overlap(&patch, existing) {
            return Err(CollisionError::OverlappingPatches {
                existing_range: existing.address_range(),
                new_range: patch.address_range(),
            });
        }
    }
    self.patches.push(patch);
    Ok(())
}
```

### 3. Ordered Patch Application
**Solution**: Apply patches in address order to prevent conflicts
```rust
fn apply_patches(&mut self) -> Result<(), Error> {
    self.patches.sort_by_key(|p| p.address());
    for patch in &self.patches {
        self.apply_single_patch(patch)?;
    }
    Ok(())
}
```

## CONCLUSION

The memory collision problem is not an edge case but a **systematic architectural flaw** affecting any sequence where:

1. A branch instruction (creating DeferredBranchPatch)
2. Is immediately followed by an instruction needing address resolution (creating UnresolvedReference)
3. Both patches target overlapping memory locations

**Impact**: Silent bytecode corruption, runtime crashes, and unpredictable behavior.

**Solution**: Unified patching system with overlap detection and coordinated memory management.