// AUTO-GENERATED by scripts/generate_opcodes.rs
// DO NOT EDIT MANUALLY - Edit opcodes_spec.toml instead
//
// Type-safe Z-Machine opcode enums based on Z-Machine Standards v1.1

#![allow(dead_code)]

use super::codegen::InstructionForm;

/// 0OP form instructions
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum Op0 {
    /// Return true (1) from current routine (176)
    /// V1+
    Rtrue = 0x00,
    /// Return false (0) from current routine (177)
    /// V1+
    Rfalse = 0x01,
    /// Print literal string embedded in instruction stream (178)
    /// V1+
    Print = 0x02,
    /// Print literal string, print newline, return true (179)
    /// V1+
    PrintRet = 0x03,
    /// No operation (180)
    /// V1+
    Nop = 0x04,
    /// Save game state (V1-3, branches on success) (181)
    /// V1-V3
    Save = 0x05,
    /// Restore game state (V1-3, branches on success) (182)
    /// V1-V3
    Restore = 0x06,
    /// Restart the game (183)
    /// V1+
    Restart = 0x07,
    /// Pop value from stack and return it (184)
    /// V1+
    RetPopped = 0x08,
    /// Pop and discard top of stack (V1-4) (185)
    /// V1-V4
    Pop = 0x09,
    /// Quit the game (186)
    /// V1+
    Quit = 0x0A,
    /// Print a newline (187)
    /// V1+
    NewLine = 0x0B,
    /// Show status line (V3 only) (188)
    /// V3-V3
    ShowStatus = 0x0C,
    /// Verify game file checksum (189)
    /// V3+
    Verify = 0x0D,
}

impl Op0 {
    /// Get the raw opcode number (0x00-0x1F)
    pub const fn raw_value(&self) -> u8 {
        *self as u8
    }

    /// Does this opcode store a result?
    pub const fn stores_result(&self) -> bool {
        match self {
            _ => false,
        }
    }

    /// Does this opcode branch?
    pub const fn branches(&self) -> bool {
        match self {
            Op0::Save => true,
            Op0::Restore => true,
            Op0::Verify => true,
            _ => false,
        }
    }

    /// Minimum Z-Machine version required
    pub const fn min_version(&self) -> u8 {
        match self {
            Op0::Rtrue
            | Op0::Rfalse
            | Op0::Print
            | Op0::PrintRet
            | Op0::Nop
            | Op0::Save
            | Op0::Restore
            | Op0::Restart
            | Op0::RetPopped
            | Op0::Pop
            | Op0::Quit
            | Op0::NewLine => 1,
            Op0::ShowStatus | Op0::Verify => 3,
        }
    }

    /// Get instruction form for this opcode
    pub const fn form(&self) -> InstructionForm {
        InstructionForm::Short
    }
}

/// 1OP form instructions
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum Op1 {
    /// Jump if zero (128)
    /// V1+
    Jz = 0x00,
    /// Get object's sibling, branch if exists (129)
    /// V1+
    GetSibling = 0x01,
    /// Get object's child, branch if exists (130)
    /// V1+
    GetChild = 0x02,
    /// Get object's parent (131)
    /// V1+
    GetParent = 0x03,
    /// Get property data length (132)
    /// V1+
    GetPropLen = 0x04,
    /// Increment variable (133)
    /// V1+
    Inc = 0x05,
    /// Decrement variable (134)
    /// V1+
    Dec = 0x06,
    /// Print string at byte address (135)
    /// V1+
    PrintAddr = 0x07,
    /// Call routine with 0 args, store result (V4+) (136)
    /// V4+
    Call1s = 0x08,
    /// Remove object from parent (137)
    /// V1+
    RemoveObj = 0x09,
    /// Print object's short name (138)
    /// V1+
    PrintObj = 0x0A,
    /// Return with value (139)
    /// V1+
    Ret = 0x0B,
    /// Unconditional jump (140)
    /// V1+
    Jump = 0x0C,
    /// Print string at packed address (141)
    /// V1+
    PrintPaddr = 0x0D,
    /// Load variable value (142)
    /// V1+
    Load = 0x0E,
    /// Call routine with 0 args, discard result (V5+) (143)
    /// V5+
    Call1n = 0x0F,
}

impl Op1 {
    /// Get the raw opcode number (0x00-0x1F)
    pub const fn raw_value(&self) -> u8 {
        *self as u8
    }

    /// Does this opcode store a result?
    pub const fn stores_result(&self) -> bool {
        match self {
            Op1::GetSibling => true,
            Op1::GetChild => true,
            Op1::GetParent => true,
            Op1::GetPropLen => true,
            Op1::Call1s => true,
            Op1::Load => true,
            _ => false,
        }
    }

    /// Does this opcode branch?
    pub const fn branches(&self) -> bool {
        match self {
            Op1::Jz => true,
            Op1::GetSibling => true,
            Op1::GetChild => true,
            _ => false,
        }
    }

    /// Minimum Z-Machine version required
    pub const fn min_version(&self) -> u8 {
        match self {
            Op1::Jz
            | Op1::GetSibling
            | Op1::GetChild
            | Op1::GetParent
            | Op1::GetPropLen
            | Op1::Inc
            | Op1::Dec
            | Op1::PrintAddr
            | Op1::RemoveObj
            | Op1::PrintObj
            | Op1::Ret
            | Op1::Jump
            | Op1::PrintPaddr
            | Op1::Load => 1,
            Op1::Call1s => 4,
            Op1::Call1n => 5,
        }
    }

    /// Get instruction form for this opcode
    pub const fn form(&self) -> InstructionForm {
        InstructionForm::Short
    }
}

/// 2OP form instructions (can use LONG or VAR form)
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum Op2 {
    /// Jump if equal (supports up to 4 operands in VAR form V4+) (1)
    /// V1+
    Je = 0x01,
    /// Jump if less than (signed) (2)
    /// V1+
    Jl = 0x02,
    /// Jump if greater than (signed) (3)
    /// V1+
    Jg = 0x03,
    /// Decrement variable and branch if < value (4)
    /// V1+
    DecChk = 0x04,
    /// Increment variable and branch if > value (5)
    /// V1+
    IncChk = 0x05,
    /// Jump if obj1 is direct child of obj2 (6)
    /// V1+
    Jin = 0x06,
    /// Jump if (bitmap & flags) == flags (7)
    /// V1+
    Test = 0x07,
    /// Bitwise OR (8)
    /// V1+
    Or = 0x08,
    /// Bitwise AND (9)
    /// V1+
    And = 0x09,
    /// Branch if object has attribute (10)
    /// V1+
    TestAttr = 0x0A,
    /// Set object attribute (11)
    /// V1+
    SetAttr = 0x0B,
    /// Clear object attribute (12)
    /// V1+
    ClearAttr = 0x0C,
    /// Store value in variable (13)
    /// V1+
    Store = 0x0D,
    /// Insert obj1 as first child of obj2 (14)
    /// V1+
    InsertObj = 0x0E,
    /// Load word from array (15)
    /// V1+
    Loadw = 0x0F,
    /// Load byte from array (16)
    /// V1+
    Loadb = 0x10,
    /// Get object property value (17)
    /// V1+
    GetProp = 0x11,
    /// Get address of object property data (18)
    /// V1+
    GetPropAddr = 0x12,
    /// Get next property number (19)
    /// V1+
    GetNextProp = 0x13,
    /// Add (signed) (20)
    /// V1+
    Add = 0x14,
    /// Subtract (signed) (21)
    /// V1+
    Sub = 0x15,
    /// Multiply (signed) (22)
    /// V1+
    Mul = 0x16,
    /// Divide (signed) (23)
    /// V1+
    Div = 0x17,
    /// Modulo (signed) (24)
    /// V1+
    Mod = 0x18,
    /// Call routine with 1 arg, store result (V4+) (25)
    /// V4+
    Call2s = 0x19,
    /// Call routine with 1 arg, discard result (V5+) (26)
    /// V5+
    Call2n = 0x1A,
    /// Set foreground/background color (V5+) (27)
    /// V5+
    SetColour = 0x1B,
    /// Throw to catch frame (V5+) (28)
    /// V5+
    Throw = 0x1C,
}

impl Op2 {
    /// Get the raw opcode number (0x00-0x1F)
    pub const fn raw_value(&self) -> u8 {
        *self as u8
    }

    /// Does this opcode store a result?
    pub const fn stores_result(&self) -> bool {
        match self {
            Op2::Or => true,
            Op2::And => true,
            Op2::Loadw => true,
            Op2::Loadb => true,
            Op2::GetProp => true,
            Op2::GetPropAddr => true,
            Op2::GetNextProp => true,
            Op2::Add => true,
            Op2::Sub => true,
            Op2::Mul => true,
            Op2::Div => true,
            Op2::Mod => true,
            Op2::Call2s => true,
            _ => false,
        }
    }

    /// Does this opcode branch?
    pub const fn branches(&self) -> bool {
        match self {
            Op2::Je => true,
            Op2::Jl => true,
            Op2::Jg => true,
            Op2::DecChk => true,
            Op2::IncChk => true,
            Op2::Jin => true,
            Op2::Test => true,
            Op2::TestAttr => true,
            _ => false,
        }
    }

    /// Minimum Z-Machine version required
    pub const fn min_version(&self) -> u8 {
        match self {
            Op2::Je
            | Op2::Jl
            | Op2::Jg
            | Op2::DecChk
            | Op2::IncChk
            | Op2::Jin
            | Op2::Test
            | Op2::Or
            | Op2::And
            | Op2::TestAttr
            | Op2::SetAttr
            | Op2::ClearAttr
            | Op2::Store
            | Op2::InsertObj
            | Op2::Loadw
            | Op2::Loadb
            | Op2::GetProp
            | Op2::GetPropAddr
            | Op2::GetNextProp
            | Op2::Add
            | Op2::Sub
            | Op2::Mul
            | Op2::Div
            | Op2::Mod => 1,
            Op2::Call2s => 4,
            Op2::Call2n | Op2::SetColour | Op2::Throw => 5,
        }
    }

    /// Get instruction form for this opcode
    pub const fn form(&self) -> InstructionForm {
        InstructionForm::Long
    }
}

/// VAR form instructions
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u8)]
pub enum OpVar {
    /// Call routine, store result (224)
    /// V1+
    CallVs = 0x00,
    /// Store word in array (225)
    /// V1+
    Storew = 0x01,
    /// Store byte in array (226)
    /// V1+
    Storeb = 0x02,
    /// Set object property value (227)
    /// V1+
    PutProp = 0x03,
    /// Read line of input (V1-V3) / Read line of input with result (V4+) (228)
    /// V1-V3 (compatible with V3 target, Aread is V4+)
    ///
    /// CRITICAL V3 COMPATIBILITY: This enum uses Sread (V1-V3) instead of Aread (V4+)
    /// because this codebase targets V3 Z-Machine. Both instructions share opcode 0x04
    /// but have different semantics. Using Sread enables type-safe emit_instruction_typed()
    /// calls while maintaining V3 compatibility.
    Sread = 0x04,
    /// Print single character (229)
    /// V1+
    PrintChar = 0x05,
    /// Print signed number (230)
    /// V1+
    PrintNum = 0x06,
    /// Random number generator (231)
    /// V1+
    Random = 0x07,
    /// Push value onto stack (232)
    /// V1+
    Push = 0x08,
    /// Pop stack into variable (V1-5) (233)
    /// V1-V5
    Pull = 0x09,
    /// Split screen window (V3+) (234)
    /// V3+
    SplitWindow = 0x0A,
    /// Select active window (V3+) (235)
    /// V3+
    SetWindow = 0x0B,
    /// Call routine with up to 7 args, store result (V4+) (236)
    /// V4+
    CallVs2 = 0x0C,
    /// Erase window (V4+) (237)
    /// V4+
    EraseWindow = 0x0D,
    /// Erase line in window (V4+) (238)
    /// V4+
    EraseLine = 0x0E,
    /// Set cursor position (V4+) (239)
    /// V4+
    SetCursor = 0x0F,
    /// Get cursor position into array (V4+) (240)
    /// V4+
    GetCursor = 0x10,
    /// Set text style (V4+) (241)
    /// V4+
    SetTextStyle = 0x11,
    /// Set buffering mode (V4+) (242)
    /// V4+
    BufferMode = 0x12,
    /// Select output stream (V3+) (243)
    /// V3+
    OutputStream = 0x13,
    /// Select input stream (V3+) (244)
    /// V3+
    InputStream = 0x14,
    /// Play sound effect (V3+) (245)
    /// V3+
    SoundEffect = 0x15,
    /// Read single character (V4+) (246)
    /// V4+
    ReadChar = 0x16,
    /// Scan table for value (V4+) (247)
    /// V4+
    ScanTable = 0x17,
    /// Bitwise NOT (V5+) (248)
    /// V5+
    Not = 0x18,
    /// Call routine, discard result (V5+) (249)
    /// V5+
    CallVn = 0x19,
    /// Call routine with up to 7 args, discard result (V5+) (250)
    /// V5+
    CallVn2 = 0x1A,
    /// Tokenize text buffer (V5+) (251)
    /// V5+
    Tokenise = 0x1B,
    /// Encode text into dictionary format (V5+) (252)
    /// V5+
    EncodeText = 0x1C,
    /// Copy table (V5+) (253)
    /// V5+
    CopyTable = 0x1D,
    /// Print formatted table (V5+) (254)
    /// V5+
    PrintTable = 0x1E,
    /// Branch if routine called with >= n args (V5+) (255)
    /// V5+
    CheckArgCount = 0x1F,
}

impl OpVar {
    /// Get the raw opcode number (0x00-0x1F)
    pub const fn raw_value(&self) -> u8 {
        *self as u8
    }

    /// Does this opcode store a result?
    pub const fn stores_result(&self) -> bool {
        match self {
            OpVar::CallVs => true,
            OpVar::Sread => true,
            OpVar::Random => true,
            OpVar::CallVs2 => true,
            OpVar::ReadChar => true,
            OpVar::ScanTable => true,
            OpVar::Not => true,
            _ => false,
        }
    }

    /// Does this opcode branch?
    pub const fn branches(&self) -> bool {
        match self {
            OpVar::ScanTable => true,
            OpVar::CheckArgCount => true,
            _ => false,
        }
    }

    /// Minimum Z-Machine version required
    pub const fn min_version(&self) -> u8 {
        match self {
            OpVar::CallVs
            | OpVar::Storew
            | OpVar::Storeb
            | OpVar::PutProp
            | OpVar::PrintChar
            | OpVar::PrintNum
            | OpVar::Random
            | OpVar::Push
            | OpVar::Pull
            | OpVar::Sread => 1,
            OpVar::SplitWindow
            | OpVar::SetWindow
            | OpVar::OutputStream
            | OpVar::InputStream
            | OpVar::SoundEffect => 3,
            OpVar::CallVs2
            | OpVar::EraseWindow
            | OpVar::EraseLine
            | OpVar::SetCursor
            | OpVar::GetCursor
            | OpVar::SetTextStyle
            | OpVar::BufferMode
            | OpVar::ReadChar
            | OpVar::ScanTable => 4,
            OpVar::Not
            | OpVar::CallVn
            | OpVar::CallVn2
            | OpVar::Tokenise
            | OpVar::EncodeText
            | OpVar::CopyTable
            | OpVar::PrintTable
            | OpVar::CheckArgCount => 5,
        }
    }

    /// Get instruction form for this opcode
    pub const fn form(&self) -> InstructionForm {
        InstructionForm::Variable
    }
}

/// Combined opcode enum that can represent any Z-Machine instruction
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Opcode {
    /// 0OP form opcode
    Op0(Op0),
    /// 1OP form opcode
    Op1(Op1),
    /// 2OP form opcode
    Op2(Op2),
    /// VAR form opcode
    OpVar(OpVar),
}

impl Opcode {
    /// Get the raw opcode value
    pub fn raw_value(&self) -> u8 {
        match self {
            Opcode::Op0(op) => op.raw_value(),
            Opcode::Op1(op) => op.raw_value(),
            Opcode::Op2(op) => op.raw_value(),
            Opcode::OpVar(op) => op.raw_value(),
        }
    }

    /// Does this instruction store a result?
    pub fn stores_result(&self) -> bool {
        match self {
            Opcode::Op0(op) => op.stores_result(),
            Opcode::Op1(op) => op.stores_result(),
            Opcode::Op2(op) => op.stores_result(),
            Opcode::OpVar(op) => op.stores_result(),
        }
    }

    /// Does this instruction branch?
    pub fn branches(&self) -> bool {
        match self {
            Opcode::Op0(op) => op.branches(),
            Opcode::Op1(op) => op.branches(),
            Opcode::Op2(op) => op.branches(),
            Opcode::OpVar(op) => op.branches(),
        }
    }

    /// Get minimum Z-Machine version
    pub fn min_version(&self) -> u8 {
        match self {
            Opcode::Op0(op) => op.min_version(),
            Opcode::Op1(op) => op.min_version(),
            Opcode::Op2(op) => op.min_version(),
            Opcode::OpVar(op) => op.min_version(),
        }
    }

    /// Get instruction form
    pub fn form(&self) -> InstructionForm {
        match self {
            Opcode::Op0(op) => op.form(),
            Opcode::Op1(op) => op.form(),
            Opcode::Op2(op) => op.form(),
            Opcode::OpVar(op) => op.form(),
        }
    }
}

/// Trait for opcode metadata
pub trait OpcodeMetadata {
    fn raw_value(&self) -> u8;
    fn stores_result(&self) -> bool;
    fn branches(&self) -> bool;
    fn min_version(&self) -> u8;
    fn form(&self) -> InstructionForm;
}

impl OpcodeMetadata for Op0 {
    fn raw_value(&self) -> u8 {
        self.raw_value()
    }
    fn stores_result(&self) -> bool {
        self.stores_result()
    }
    fn branches(&self) -> bool {
        self.branches()
    }
    fn min_version(&self) -> u8 {
        self.min_version()
    }
    fn form(&self) -> InstructionForm {
        self.form()
    }
}

impl OpcodeMetadata for Op1 {
    fn raw_value(&self) -> u8 {
        self.raw_value()
    }
    fn stores_result(&self) -> bool {
        self.stores_result()
    }
    fn branches(&self) -> bool {
        self.branches()
    }
    fn min_version(&self) -> u8 {
        self.min_version()
    }
    fn form(&self) -> InstructionForm {
        self.form()
    }
}

impl OpcodeMetadata for Op2 {
    fn raw_value(&self) -> u8 {
        self.raw_value()
    }
    fn stores_result(&self) -> bool {
        self.stores_result()
    }
    fn branches(&self) -> bool {
        self.branches()
    }
    fn min_version(&self) -> u8 {
        self.min_version()
    }
    fn form(&self) -> InstructionForm {
        self.form()
    }
}

impl OpcodeMetadata for OpVar {
    fn raw_value(&self) -> u8 {
        self.raw_value()
    }
    fn stores_result(&self) -> bool {
        self.stores_result()
    }
    fn branches(&self) -> bool {
        self.branches()
    }
    fn min_version(&self) -> u8 {
        self.min_version()
    }
    fn form(&self) -> InstructionForm {
        self.form()
    }
}

// Convenience constants for common opcodes
// These can be used directly without enum qualification

pub const QUIT: Opcode = Opcode::Op0(Op0::Quit);
pub const NEWLINE: Opcode = Opcode::Op0(Op0::NewLine);
pub const RTRUE: Opcode = Opcode::Op0(Op0::Rtrue);
pub const RFALSE: Opcode = Opcode::Op0(Op0::Rfalse);

pub const PRINTPADDR: Opcode = Opcode::Op1(Op1::PrintPaddr);
pub const JZ: Opcode = Opcode::Op1(Op1::Jz);
pub const LOAD: Opcode = Opcode::Op1(Op1::Load);
pub const RET: Opcode = Opcode::Op1(Op1::Ret);
pub const JUMP: Opcode = Opcode::Op1(Op1::Jump);

pub const JE: Opcode = Opcode::Op2(Op2::Je);
pub const JL: Opcode = Opcode::Op2(Op2::Jl);
pub const JG: Opcode = Opcode::Op2(Op2::Jg);
pub const ADD: Opcode = Opcode::Op2(Op2::Add);
pub const SUB: Opcode = Opcode::Op2(Op2::Sub);
pub const MUL: Opcode = Opcode::Op2(Op2::Mul);
pub const DIV: Opcode = Opcode::Op2(Op2::Div);
pub const STORE: Opcode = Opcode::Op2(Op2::Store);

pub const CALLVS: Opcode = Opcode::OpVar(OpVar::CallVs);
pub const PUTPROP: Opcode = Opcode::OpVar(OpVar::PutProp);
pub const PRINTCHAR: Opcode = Opcode::OpVar(OpVar::PrintChar);
pub const PRINTNUM: Opcode = Opcode::OpVar(OpVar::PrintNum);
