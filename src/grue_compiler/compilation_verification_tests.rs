//! Compilation Verification Tests - Phase 1
//!
//! These tests verify that the compiler can successfully compile games
//! without branch offset overflow errors and generate valid Z-Machine bytecode.

#[cfg(test)]
mod compilation_verification_tests {
    use crate::grue_compiler::{GrueCompiler, ZMachineVersion};
    use std::fs;

    /// Test that mini_zork.grue compiles without branch overflow errors
    #[test]
    fn test_mini_zork_compilation_success() {
        let compiler = GrueCompiler::new();

        // Read the mini_zork.grue source
        let source = fs::read_to_string("examples/mini_zork.grue")
            .expect("Could not read examples/mini_zork.grue");

        // Attempt compilation - this should NOT fail with branch overflow
        let result = compiler.compile(&source, ZMachineVersion::V3);

        match result {
            Ok((bytecode, _)) => {
                assert!(!bytecode.is_empty(), "Bytecode should not be empty");
                println!(
                    "✅ Compilation successful: {} bytes generated",
                    bytecode.len()
                );
            }
            Err(e) => {
                // Check if this is the specific branch overflow error we're fixing
                let error_msg = format!("{:?}", e);
                if error_msg.contains("branch offset") && error_msg.contains("out of range") {
                    panic!("❌ Branch overflow error still occurring: {}", error_msg);
                } else {
                    // Other compilation errors are not what we're testing here
                    panic!("❌ Unexpected compilation error: {}", error_msg);
                }
            }
        }
    }

    /// Test that generated bytecode has valid Z-Machine header structure
    #[test]
    fn test_generated_bytecode_valid_zmachine_format() {
        let compiler = GrueCompiler::new();

        let source = fs::read_to_string("examples/mini_zork.grue")
            .expect("Could not read examples/mini_zork.grue");

        if let Ok((bytecode, _)) = compiler.compile(&source, ZMachineVersion::V3) {
            // Z-Machine files must be at least 64 bytes (header size)
            assert!(
                bytecode.len() >= 64,
                "Z-Machine file too small: {} bytes",
                bytecode.len()
            );

            // Check Z-Machine version in header (byte 0)
            assert_eq!(bytecode[0], 3, "Should be Z-Machine version 3");

            // Check that we have some code beyond the header
            assert!(
                bytecode.len() > 1024,
                "File should contain substantial code: {} bytes",
                bytecode.len()
            );

            // Look for patterns that suggest branch instructions are present
            // (We'll expand this as we implement the fix)
            let mut branch_patterns_found = 0;
            for i in 0..bytecode.len().saturating_sub(2) {
                // Look for potential 2-byte branch patterns
                // Bit 7 = 1 (branch on true), Bit 6 = 0 (2-byte format)
                if (bytecode[i] & 0xC0) == 0x80 {
                    branch_patterns_found += 1;
                }
            }

            // We should find at least some branch instructions in a typical game
            assert!(
                branch_patterns_found > 0,
                "Should find branch instruction patterns"
            );
            println!(
                "✅ Found {} potential 2-byte branch patterns",
                branch_patterns_found
            );
        } else {
            // If compilation fails, skip this test - the main compilation test will catch it
            println!("⚠️  Skipping bytecode validation due to compilation failure");
        }
    }

    /// Test that branch instruction format bits are correctly set for 2-byte branches
    #[test]
    fn test_branch_format_bits_consistency() {
        // This test verifies our understanding of Z-Machine branch encoding
        // Will be expanded during implementation to check actual bytecode

        // 2-byte branch format: bit 7 (branch on condition), bit 6 = 0 (2-byte)
        let branch_on_true_2byte = 0x80; // 10000000
        let branch_on_false_2byte = 0x00; // 00000000

        // 1-byte branch format: bit 7 (branch on condition), bit 6 = 1 (1-byte)
        let branch_on_true_1byte = 0xC0; // 11000000
        let branch_on_false_1byte = 0x40; // 01000000

        // Verify our bit manipulation understanding
        assert_eq!(
            branch_on_true_2byte & 0x40,
            0x00,
            "2-byte format has bit 6 = 0"
        );
        assert_eq!(
            branch_on_true_1byte & 0x40,
            0x40,
            "1-byte format has bit 6 = 1"
        );
        assert_eq!(
            branch_on_false_2byte & 0x40,
            0x00,
            "2-byte format has bit 6 = 0"
        );
        assert_eq!(
            branch_on_false_1byte & 0x40,
            0x40,
            "1-byte format has bit 6 = 1"
        );

        println!("✅ Branch format bit understanding verified");
    }

    /// Test compilation of edge case that triggers the overflow
    #[test]
    fn test_branch_overflow_edge_case_compilation() {
        // This test specifically targets the problematic offset 75 case
        // For now, we just verify compilation doesn't panic

        let compiler = GrueCompiler::new();
        let source = fs::read_to_string("examples/mini_zork.grue")
            .expect("Could not read examples/mini_zork.grue");

        match compiler.compile(&source, ZMachineVersion::V3) {
            Ok(_) => {
                println!("✅ No branch overflow crash - compilation succeeded");
            }
            Err(e) => {
                let error_msg = format!("{:?}", e);
                if error_msg.contains("1-byte branch offset 75 out of range") {
                    println!(
                        "⚠️  Expected branch overflow error still present: {}",
                        error_msg
                    );
                    // This is expected before our fix - not a test failure
                    // The test passes as long as it doesn't panic
                } else {
                    panic!("❌ Unexpected error type: {}", error_msg);
                }
            }
        }
    }

    /// Test that compilation generates reasonable file sizes
    #[test]
    fn test_compilation_file_size_baseline() {
        let compiler = GrueCompiler::new();
        let source = fs::read_to_string("examples/mini_zork.grue")
            .expect("Could not read examples/mini_zork.grue");

        if let Ok((bytecode, _)) = compiler.compile(&source, ZMachineVersion::V3) {
            let size = bytecode.len();

            // Sanity check: should be reasonable size for a small game
            assert!(size > 1000, "File seems too small: {} bytes", size);
            assert!(size < 100000, "File seems too large: {} bytes", size);

            println!("✅ Baseline file size: {} bytes ({}KB)", size, size / 1024);

            // During Phase 2+, we'll compare this to post-conversion sizes
            // Target: <5% increase after 2-byte conversion
        } else {
            println!("⚠️  Skipping file size baseline due to compilation failure");
        }
    }

    /// Test that we can detect when all branches use 2-byte format
    #[test]
    fn test_can_detect_2byte_branch_conversion() {
        // This test establishes the framework for verifying conversion success
        // Will be expanded during implementation

        let compiler = GrueCompiler::new();
        let source = fs::read_to_string("examples/mini_zork.grue")
            .expect("Could not read examples/mini_zork.grue");

        if let Ok((bytecode, _)) = compiler.compile(&source, ZMachineVersion::V3) {
            let mut one_byte_branches = 0;
            let mut two_byte_branches = 0;

            // Scan for branch instruction patterns
            for i in 0..bytecode.len().saturating_sub(2) {
                let byte = bytecode[i];
                // Check if this looks like a branch instruction first byte
                if (byte & 0x80) != 0 || (byte & 0x40) != 0 {
                    // Examine the format bit (bit 6)
                    if (byte & 0x40) == 0x40 {
                        one_byte_branches += 1;
                    } else if (byte & 0x40) == 0x00 {
                        two_byte_branches += 1;
                    }
                }
            }

            println!(
                "✅ Branch pattern analysis: {} 1-byte, {} 2-byte patterns found",
                one_byte_branches, two_byte_branches
            );

            // During Phase 2+, we'll verify that one_byte_branches goes to 0
            // and two_byte_branches increases accordingly
        } else {
            println!("⚠️  Skipping branch detection due to compilation failure");
        }
    }

    /// Test multiple Z-Machine versions for compatibility
    #[test]
    fn test_multiple_zmachine_versions_compilation() {
        let compiler = GrueCompiler::new();
        let source = fs::read_to_string("examples/mini_zork.grue")
            .expect("Could not read examples/mini_zork.grue");

        // Test V3 (our primary target)
        match compiler.compile(&source, ZMachineVersion::V3) {
            Ok((bytecode, _)) => {
                assert_eq!(bytecode[0], 3, "V3 version byte should be 3");
                println!("✅ V3 compilation: {} bytes", bytecode.len());
            }
            Err(e) => {
                println!("⚠️  V3 compilation failed: {:?}", e);
            }
        }

        // Test V4 compatibility
        match compiler.compile(&source, ZMachineVersion::V4) {
            Ok((bytecode, _)) => {
                assert_eq!(bytecode[0], 4, "V4 version byte should be 4");
                println!("✅ V4 compilation: {} bytes", bytecode.len());
            }
            Err(e) => {
                println!("⚠️  V4 compilation failed: {:?}", e);
            }
        }

        // Test V5 compatibility
        match compiler.compile(&source, ZMachineVersion::V5) {
            Ok((bytecode, _)) => {
                assert_eq!(bytecode[0], 5, "V5 version byte should be 5");
                println!("✅ V5 compilation: {} bytes", bytecode.len());
            }
            Err(e) => {
                println!("⚠️  V5 compilation failed: {:?}", e);
            }
        }
    }
}
